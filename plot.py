# plot_results.py

# Script to visualize the approximation quality of the  algorithms.

# Loads results from a .pkl file (generated by main.py), computes the average approximation ratio (ALG / OPT)
# for different values of n (number of items), and plots the ratio with error bars (standard deviation).
# The plot helps evaluate how the performance of the approximation algorithms scales with problem size.

import pickle
import matplotlib
matplotlib.use('TkAgg')  # Use TkAgg backend for matplotlib
import matplotlib.pyplot as plt
import numpy as np
import os

def plot_approximation_ratios_primal(criterion, num_runs, N, output_dir="results"):
    pkl_file = f"{output_dir}/all_results_{criterion}.pkl"
    output_plot = f"{output_dir}/plot_ratio_{criterion}.png"

    if not os.path.exists(pkl_file):
        print(f"⚠️ File {pkl_file} not found.")
        return

    # Load results
    with open(pkl_file, "rb") as f:
        all_results = pickle.load(f)

    # Organize data by n
    n_to_ratios = {}
    for entry in all_results:
        n = entry["n"]
        ratio = entry["ratio_primal_opt"]
        if n not in n_to_ratios:
            n_to_ratios[n] = []
        n_to_ratios[n].append(ratio)

    # Prepare data for plotting
    n_values = sorted(n_to_ratios.keys())
    avg_ratios = [np.mean(n_to_ratios[n]) for n in n_values]
    #std_devs = [np.std(n_to_ratios[n]) for n in n_values]
    ci_95 = [1.96 * np.std(n_to_ratios[n]) / np.sqrt(len(n_to_ratios[n])) for n in n_values]

    # Plot
    plt.figure(figsize=(10, 6))
    plt.errorbar(n_values, avg_ratios, yerr=ci_95, fmt='-o', capsize=5, label="Primal Rounding (Ø ± 95% CI)")
    plt.xlabel("Number of items (n)")
    plt.ylabel("Approximation ratio (ALG / OPT)")
    titles = {"minmax": "Min-Max", "maxmin": "Max-Min"}
    plt.title(f"Approximation Ratio ({titles[criterion]}): Primal Rounding vs. Optimal\n"
              f"(Average over {num_runs} runs, {N} scenarios)")
    plt.grid(True, linestyle='--', alpha=0.5)
    plt.xticks(n_values)
    # if criterion == "minmax":
    #     plt.ylim(1.0, 1.2)
    # elif criterion == "maxmin":
    #     plt.ylim(0.8, 1.0)
    plt.legend()
    plt.tight_layout()
    plt.savefig(output_plot)
    # plt.show()  # if activated: close plot window to continue execution of run_all.py
    print(f"✅ Plot saved to {output_plot}")

def plot_integrality_gap_primal(criterion, num_runs, N, output_dir="results"):
    pkl_file = os.path.join(output_dir, f"all_results_{criterion}.pkl")
    output_plot = os.path.join(output_dir, f"plot_integrality_gap_{criterion}.png")

    if not os.path.exists(pkl_file):
        print(f"⚠️ File {pkl_file} not found.")
        return

    # Load results
    with open(pkl_file, "rb") as f:
        all_results = pickle.load(f)

    # Organize data by n
    n_to_gaps = {}
    for entry in all_results:
        n = entry["n"]
        n_to_gaps.setdefault(n, []).append(entry["integrality_gap"])

    # Prepare data for plotting
    n_values = sorted(n_to_gaps.keys())
    avg_vals = [np.mean(n_to_gaps[n]) for n in n_values]
    ci_vals = [1.96 * np.std(n_to_gaps[n]) / np.sqrt(len(n_to_gaps[n])) for n in n_values]

    # Plot
    plt.figure(figsize=(10, 6))
    plt.errorbar(n_values, avg_vals, yerr=ci_vals, fmt='-o', capsize=5, color="tab:blue", label="Integrality Gap")
    plt.xlabel("Number of items (n)")
    ylabel = "IP Objective / LP Objective" if criterion == "minmax" else "LP Objective / IP Objective"
    plt.ylabel(ylabel)
    titles = {"minmax": "Min-Max", "maxmin": "Max-Min"}
    plt.title(f"Integrality Gap ({titles[criterion]})\n(Average over {num_runs} runs, {N} scenarios)")
    plt.grid(True, linestyle='--', alpha=0.5)
    plt.legend()
    plt.xticks(n_values)
    plt.tight_layout()
    plt.savefig(output_plot)
    plt.close()
    print(f"✅ Integrality gap plot saved to {output_plot}")

def plot_rounding_gap_primal(criterion, num_runs, N, output_dir="results"):
    pkl_file = os.path.join(output_dir, f"all_results_{criterion}.pkl")
    output_plot = os.path.join(output_dir, f"plot_rounding_gap_{criterion}.png")

    if not os.path.exists(pkl_file):
        print(f"⚠️ File {pkl_file} not found.")
        return

    # Load results
    with open(pkl_file, "rb") as f:
        all_results = pickle.load(f)

    # Organize data by n
    n_to_gaps = {}
    for entry in all_results:
        n = entry["n"]
        n_to_gaps.setdefault(n, []).append(entry["rounding_gap"])

    # Prepare data for plotting
    n_values = sorted(n_to_gaps.keys())
    avg_vals = [np.mean(n_to_gaps[n]) for n in n_values]
    ci_vals = [1.96 * np.std(n_to_gaps[n]) / np.sqrt(len(n_to_gaps[n])) for n in n_values]

    # Plot
    plt.figure(figsize=(10, 6))
    plt.errorbar(n_values, avg_vals, yerr=ci_vals, fmt='-s', capsize=5, color="tab:orange", label="Rounding Gap")
    plt.xlabel("Number of items (n)")
    plt.ylabel("Rounded Objective / LP Objective")
    titles = {"minmax": "Min-Max", "maxmin": "Max-Min"}
    plt.title(f"Rounding Gap ({titles[criterion]})\n(Average over {num_runs} runs, {N} scenarios)")
    plt.grid(True, linestyle='--', alpha=0.5)
    plt.legend()
    plt.xticks(n_values)
    plt.tight_layout()
    plt.savefig(output_plot)
    plt.close()
    print(f"✅ Rounding gap plot saved to {output_plot}")

def plot_histogram_of_xvals(n_to_xvals, output_dir="results", n_to_max_frac_count=None):
    for n, xvals in n_to_xvals.items():
        plt.figure(figsize=(8, 5))
        plt.hist(xvals, bins=20, edgecolor='black')

        if n_to_max_frac_count and n in n_to_max_frac_count:
            max_count = n_to_max_frac_count[n]
            title = f"LP x[i] values for n = {n}\nMax. # fractional x[i]: {max_count}"
        else:
            title = f"LP x[i] values for n = {n}"

        plt.title(title)
        plt.xlabel("x[i] value")
        plt.ylabel("Frequency")
        plt.tight_layout()
        output_file = os.path.join(output_dir, f"histogram_xvals_n_{n}.png")
        plt.savefig(output_file)
        plt.close()
        print(f"✅ Histogram for n = {n} saved to {output_file}")

def plot_fractional_variable_count(criterion, num_runs, N, output_dir="results"):
    pkl_file = os.path.join(output_dir, f"all_results_{criterion}.pkl")
    output_plot = os.path.join(output_dir, f"plot_fractional_count_{criterion}.png")

    if not os.path.exists(pkl_file):
        print(f"⚠️ File {pkl_file} not found.")
        return

    # Load data
    with open(pkl_file, "rb") as f:
        all_results = pickle.load(f)

    # Group by n
    n_values = []
    frac_counts = []

    for entry in all_results:
        n_values.append(entry["n"])
        frac_counts.append(entry["fractional_count"])

    # Convert to numpy arrays for easier manipulation
    n_array = np.array(n_values)
    frac_array = np.array(frac_counts)
    # Add jitter to x-axis so overlapping points become visible
    jitter_strength = 0.3
    x_jittered = n_array + np.random.uniform(-jitter_strength, jitter_strength, size=len(n_array))

    # Plot
    plt.figure(figsize=(10, 6))
    plt.scatter(x_jittered, frac_array, alpha=0.5, label="Fractional variables (per run)")
    plt.axhline(y=N, color='red', linestyle='--', label=f"Theoretical upper bound (N = {N})")
    plt.xlabel("Number of items (n)")
    plt.ylabel("Number of fractional variables")
    titles = {"minmax": "Min-Max", "maxmin": "Max-Min"}
    plt.title(f"Scatter: Fractional Variables ({titles[criterion]})\n(Each point = one run)")
    plt.grid(True, linestyle="--", alpha=0.5)
    plt.legend()
    plt.xticks(sorted(set(n_values)))  # Only unique n's on x-axis
    plt.tight_layout()
    plt.savefig(output_plot)
    plt.close()
    print(f"✅ Fractional variable plot saved to {output_plot}")
