# plot_results.py

# Script to visualize the approximation quality of the  algorithms.

# Loads results from a .pkl file (generated by main.py), computes the average approximation ratio (ALG / OPT)
# for different values of n (number of items), and plots the ratio with error bars (standard deviation).
# The plot helps evaluate how the performance of the approximation algorithms scales with problem size.

import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import os
matplotlib.use('TkAgg')  # Use TkAgg backend for matplotlib

# Global matplotlib settings for consistent styling
matplotlib.rcParams.update({
    "text.usetex": True,
    "font.family": "serif",
    "font.serif": ["Computer Modern"],
    "axes.labelsize": 12,
    "font.size": 12,
    "legend.fontsize": 10,
    "xtick.labelsize": 10,
    "ytick.labelsize": 10,
    "grid.linestyle": ":",
    "grid.linewidth": 0.5,
    "grid.alpha": 0.4,
    "axes.grid": True,
    "figure.figsize": (10, 6)
})


def plot_primal_rounding_only(all_results, num_runs, var_param, output_dir="results"):
    criterion = "minmax"
    output_plot = f"{output_dir}/plot_primal_rounding_only_{criterion}.png"

    # Organize data by varying parameter (n, k, p)
    param_to_ratios = {}
    for entry in all_results:
        param = entry["varying_param"]
        ratio = entry["ratio_primal_opt"]
        param_to_ratios.setdefault(param, []).append(ratio)

    # Prepare data for plotting
    param_values = sorted(param_to_ratios.keys())
    avg_ratios = [np.mean(param_to_ratios[param]) for param in param_values]
    ci_ratios_95 = [1.96 * np.std(param_to_ratios[param]) / np.sqrt(len(param_to_ratios[param]))
                    for param in param_values]

    # Plot
    plt.errorbar(param_values, avg_ratios, yerr=ci_ratios_95, fmt='-o', capsize=5,
                 label="Primal Rounding (Ø $\\pm$ 95\\% CI)")
    xlabel_map = {
        "n": r"Number of items $n$",
        "k": r"Number of scenarios $k$",
        "p": r"Number of items to select $p$"
    }
    plt.xlabel(xlabel_map.get(var_param, ""))
    plt.ylabel(r"Approximation ratio $\mathrm{ALG}/\mathrm{OPT}$")
    titles = {"minmax": "Min-Max", "maxmin": "Max-Min"}
    plt.title(f"Primal Rounding Approximation Ratio ({titles[criterion]})\n"f"(Average over {num_runs} runs)")
    plt.xticks(param_values, rotation=45)
    plt.legend()
    plt.tight_layout()
    plt.savefig(output_plot)
    print(f"✅ Plot saved to {output_plot}")


def plot_approximation_ratios_primal(all_results, num_runs, k, output_dir="results"):
    criterion = "minmax"
    output_plot = f"{output_dir}/plot_ratio_{criterion}.png"

    # Organize data by n
    n_to_ratios = {}
    n_to_bounds = {}
    n_to_guarantee = {}
    n_to_optlp_div_alg = {}
    for entry in all_results:
        n = entry["n"]
        ratio = entry["ratio_primal_opt"]
        bound = entry["a_posteriori_bound"]
        guarantee = entry["approximation_guarantee"]
        opt_lp_div_alg = entry["opt_lp_div_alg"]
        n_to_ratios.setdefault(n, []).append(ratio)
        n_to_bounds.setdefault(n, []).append(bound)
        n_to_guarantee.setdefault(n, []).append(guarantee)
        n_to_optlp_div_alg.setdefault(n, []).append(opt_lp_div_alg)

    # Prepare data for plotting
    n_values = sorted(n_to_ratios.keys())
    avg_ratios = [np.mean(n_to_ratios[n]) for n in n_values]
    # std_devs = [np.std(n_to_ratios[n]) for n in n_values]
    ci_ratios_95 = [1.96 * np.std(n_to_ratios[n]) / np.sqrt(len(n_to_ratios[n])) for n in n_values]
    avg_bounds = [np.mean(n_to_bounds[n]) for n in n_values]
    ci_bounds_95 = [1.96 * np.std(n_to_bounds[n]) / np.sqrt(len(n_to_bounds[n])) for n in n_values]
    avg_guarantees = [np.mean(n_to_guarantee[n]) for n in n_values]
    avg_optlp_div_alg = [np.mean(n_to_optlp_div_alg[n]) for n in n_values]
    ci_optlp_div_alg_95 = [
        1.96 * np.std(n_to_optlp_div_alg[n]) / np.sqrt(len(n_to_optlp_div_alg[n])) for n in n_values
    ]

    # Plot
    plt.figure()
    plt.errorbar(n_values, avg_ratios, yerr=ci_ratios_95, fmt='-o', capsize=5,
                 label="Primal Rounding (Ø $\\pm$ 95\\% CI)")
    plt.errorbar(n_values, avg_bounds, yerr=ci_bounds_95, fmt='--s', capsize=5,
                 label=r"A-posteriori bound $1/\tau$ (Ø $\pm$ 95\% CI)")
    plt.errorbar(n_values, avg_optlp_div_alg, yerr=ci_optlp_div_alg_95, fmt='-.d', capsize=5,
                 label=r"A-posteriori bound $\mathrm{OPT}_{\mathrm{LP}} / \mathrm{ALG}$ (Ø $\pm$ 95\% CI)")
    plt.plot(n_values, avg_guarantees, ':^', label=r"Approximation guarantee $\min(k, n - p + 1)$")
    plt.xlabel(r"Number of items $n$")
    plt.ylabel(r"Relative performance ratio")
    plt.yscale('log')
    titles = {"minmax": "Min-Max", "maxmin": "Max-Min"}
    plt.title(f"Approximation Ratio vs. Approximation guarantees\n"
              f"(Average over {num_runs} runs, {k} scenarios)")
    plt.xticks(n_values)
    # plt.ylim(1.0, 1.5)
    plt.legend()
    plt.tight_layout()
    plt.savefig(output_plot)
    print(f"✅ Plot saved to {output_plot}")


def plot_integrality_gap_primal(all_results, num_runs, k, output_dir="results"):
    criterion = "minmax"
    output_plot = os.path.join(output_dir, f"plot_integrality_gap_{criterion}.png")

    # Organize data by n
    n_to_gaps = {}
    for entry in all_results:
        n = entry["n"]
        n_to_gaps.setdefault(n, []).append(entry["integrality_gap"])

    # Prepare data for plotting
    n_values = sorted(n_to_gaps.keys())
    avg_vals = [np.mean(n_to_gaps[n]) for n in n_values]
    ci_vals = [1.96 * np.std(n_to_gaps[n]) / np.sqrt(len(n_to_gaps[n])) for n in n_values]

    # Plot
    plt.figure()
    plt.errorbar(n_values, avg_vals, yerr=ci_vals, fmt='-o', capsize=5, color="tab:blue", label="Integrality Gap")
    plt.xlabel("Number of items (n)")
    ylabel = "IP Objective / LP Objective" if criterion == "minmax" else "LP Objective / IP Objective"
    plt.ylabel(ylabel)
    titles = {"minmax": "Min-Max", "maxmin": "Max-Min"}
    plt.title(f"Integrality Gap ({titles[criterion]})\n(Average over {num_runs} runs, {k} scenarios)")
    plt.legend()
    plt.xticks(n_values)
    if criterion == "minmax":
        plt.ylim(1.0, 1.3)
    elif criterion == "maxmin":
        plt.ylim(0.7, 1.0)
    plt.tight_layout()
    plt.savefig(output_plot)
    plt.close()
    print(f"✅ Integrality gap plot saved to {output_plot}")


def plot_rounding_gap_primal(all_results, num_runs, k, output_dir="results"):
    criterion = "minmax"
    output_plot = os.path.join(output_dir, f"plot_rounding_gap_{criterion}.png")

    # Organize data by n
    n_to_gaps = {}
    for entry in all_results:
        n = entry["n"]
        n_to_gaps.setdefault(n, []).append(entry["rounding_gap"])

    # Prepare data for plotting
    n_values = sorted(n_to_gaps.keys())
    avg_vals = [np.mean(n_to_gaps[n]) for n in n_values]
    ci_vals = [1.96 * np.std(n_to_gaps[n]) / np.sqrt(len(n_to_gaps[n])) for n in n_values]

    # Plot
    plt.figure()
    plt.errorbar(n_values, avg_vals, yerr=ci_vals, fmt='-s', capsize=5, color="tab:orange", label="Rounding Gap")
    plt.xlabel("Number of items (n)")
    plt.ylabel("Rounded Objective / LP Objective")
    titles = {"minmax": "Min-Max", "maxmin": "Max-Min"}
    plt.title(f"Rounding Gap ({titles[criterion]})\n(Average over {num_runs} runs, {k} scenarios)")
    plt.legend()
    plt.xticks(n_values)
    plt.ylim(1.0, 1.3)
    plt.tight_layout()
    plt.savefig(output_plot)
    plt.close()
    print(f"✅ Rounding gap plot saved to {output_plot}")


def plot_fractional_variable_count(all_results, num_runs, k, output_dir="results"):
    criterion = "minmax"
    output_plot = os.path.join(output_dir, f"plot_fractional_count_{criterion}.png")

    # Group by n
    n_values = []
    frac_counts = []

    for entry in all_results:
        n_values.append(entry["n"])
        frac_counts.append(entry["fractional_count"])

    # Convert to numpy arrays for easier manipulation
    n_array = np.array(n_values)
    frac_array = np.array(frac_counts)
    # Add jitter to x-axis so overlapping points become visible
    jitter_strength = 0.3
    x_jittered = n_array + np.random.uniform(-jitter_strength, jitter_strength, size=len(n_array))

    # Plot
    plt.figure()
    plt.scatter(x_jittered, frac_array, alpha=0.5, label="Fractional variables (per run)")
    plt.axhline(y=k, color='red', linestyle='--', label=f"Theoretical upper bound (k = {k})")
    plt.xlabel("Number of items (n)")
    plt.ylabel("Number of fractional variables")
    titles = {"minmax": "Min-Max", "maxmin": "Max-Min"}
    plt.title(f"Scatter: Fractional Variables ({titles[criterion]})\n(Each point = one run)")
    plt.legend()
    plt.xticks(sorted(set(n_values)))  # Only unique n's on x-axis
    plt.tight_layout()
    plt.savefig(output_plot)
    plt.close()
    print(f"✅ Fractional variable plot saved to {output_plot}")
